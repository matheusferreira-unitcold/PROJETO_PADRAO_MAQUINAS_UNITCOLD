import tkinter as tk
from tkinter import ttk, messagebox
import pandas as pd
import os
import re

class FancoleteConfigurador:
    def __init__(self, root):
        self.root = root
        self.root.title("Configurador de Fancoletes")
        self.root.geometry("800x1000")
        
        # Caminho da planilha
        self.planilha_path = r"C:\Users\unitc\Unitcold\TI Unitcold - Documentos\PROJETO_PADRAO_MAQUINAS_UNITCOLD\Estrutura_de_equipamentos.xlsx"
        
        # Verificar se a planilha existe
        if not os.path.exists(self.planilha_path):
            messagebox.showerror("Erro", f"Planilha não encontrada em:\n{self.planilha_path}")
            self.root.destroy()
            return
        
        # Carregar dados da planilha
        try:
            self.df = pd.read_excel(self.planilha_path, sheet_name='fancoletes', header=None)
            
            if len(self.df.columns) < 6:
                messagebox.showerror("Erro", "A planilha deve ter pelo menos 6 colunas (A-F)")
                self.root.destroy()
                return
                
            self.classificacoes = self.obter_classificacoes()
            
            if not self.classificacoes:
                messagebox.showerror("Erro", "Não foram encontradas classificações de equipamentos na coluna F")
                self.root.destroy()
                return
                
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao ler planilha:\n{str(e)}")
            self.root.destroy()
            return
        
        # Variáveis de controle
        self.classificacao_selecionada = tk.StringVar()
        self.familia_selecionada = tk.StringVar()
        self.codigo_exemplo = tk.StringVar()
        self.selecoes = {}
        self.campos_editaveis = {}
        
        self.create_widgets()

    def obter_classificacoes(self):
        classificacoes = []
        for _, row in self.df.iterrows():
            classificacao = str(row[5]).strip() if pd.notna(row[5]) else None
            if classificacao and classificacao not in classificacoes:
                classificacoes.append(classificacao)
        return sorted(classificacoes)

    def processar_planilha_para_classificacao(self, classificacao):
        dados = {}
        try:
            nivel_1 = None
            
            for _, row in self.df.iterrows():
                if str(row[5]).strip() == classificacao and pd.notna(row[0]):
                    codigo = str(row[0]).strip()
                    nivel = str(row[1]).strip() if pd.notna(row[1]) else None
                    descricao = str(row[4]).strip() if len(row) > 4 and pd.notna(row[4]) else ""
                    
                    if nivel and codigo and nivel != "1":
                        # Identifica se é campo editável
                        if codigo.lower() in ['x/x', 'xr']:
                            # Armazena como tupla especial
                            dados.setdefault(f"({nivel.zfill(2)})", []).append(('EDITAVEL', codigo, descricao))
                        else:
                            dados.setdefault(f"({nivel.zfill(2)})", []).append((codigo, descricao))
                    
                    if nivel == "1" and pd.notna(row[0]):
                        nivel_1 = codigo
            
            return nivel_1, dados
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao processar planilha:\n{str(e)}")
            return None, None

    def create_widgets(self):
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        self.scrollable_frame = tk.Frame(canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Vincular o evento de scroll do mouse ao canvas e ao frame
        canvas.bind_all("<MouseWheel>", lambda e: self._on_mousewheel(e, canvas))
        self.scrollable_frame.bind_all("<MouseWheel>", lambda e: self._on_mousewheel(e, canvas))
        
        # Frame de conteúdo principal
        self.content_frame = tk.Frame(self.scrollable_frame)
        self.content_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Frame para seleção de classificação
        self.classificacao_frame = tk.Frame(self.content_frame, padx=10, pady=10)
        self.classificacao_frame.pack(fill=tk.X)
        
        tk.Label(self.classificacao_frame, text="Classificação do Equipamento:", font=("Arial", 11)).pack(side=tk.LEFT, padx=5)
        
        self.classificacao_combo = ttk.Combobox(
            self.classificacao_frame,
            values=self.classificacoes,
            textvariable=self.classificacao_selecionada,
            state="readonly",
            font=("Arial", 11),
            width=30
        )
        self.classificacao_combo.pack(side=tk.LEFT, padx=5)
        self.classificacao_combo.bind("<<ComboboxSelected>>", self.atualizar_estrutura)
        
        # Frame para nome inicial (Nível 1)
        self.nivel1_frame = tk.Frame(self.content_frame, padx=10, pady=5)
        
        # Frame para seleção de família
        self.familia_frame = tk.Frame(self.content_frame, padx=10, pady=5)
        
        # Exemplo de código
        self.exemplo_frame = tk.Frame(self.content_frame, bd=2, relief=tk.GROOVE, padx=10, pady=5)
        
        # Frames para os níveis
        self.niveis_frames = {}
        
        # Frame para os botões no final
        self.bottom_frame = tk.Frame(self.scrollable_frame)
        
        # Botões
        self.btn_frame = tk.Frame(self.bottom_frame, pady=15)
        
        self.btn_limpar = tk.Button(
            self.btn_frame,
            text="Limpar Tudo",
            command=self.limpar_selecoes,
            font=("Arial", 10),
            width=15
        )
        self.btn_limpar.pack(side=tk.LEFT, padx=10)
        
        self.btn_gerar = tk.Button(
            self.btn_frame,
            text="Gerar Código",
            command=self.gerar_codigo,
            font=("Arial", 10, "bold"),
            bg="#4CAF50",
            fg="white",
            width=15
        )
        self.btn_gerar.pack(side=tk.LEFT, padx=10)
        
        # Área do código gerado
        self.codigo_frame = tk.Frame(self.bottom_frame)
        tk.Label(self.codigo_frame, text="Código gerado:", font=("Arial", 11)).pack(anchor="w", padx=10, pady=5)
        
        self.codigo_var = tk.StringVar()
        self.codigo_label = tk.Label(
            self.codigo_frame, 
            textvariable=self.codigo_var,
            font=("Courier", 12, "bold"),
            bg="#f0f0f0",
            padx=10,
            pady=5,
            wraplength=700,
            justify=tk.LEFT
        )
        self.codigo_label.pack(fill=tk.X, padx=10, pady=5)

    def _on_mousewheel(self, event, canvas):
        # Função para lidar com o scroll do mouse
        if event.delta:
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        else:
            if event.num == 4:
                canvas.yview_scroll(-1, "units")
            elif event.num == 5:
                canvas.yview_scroll(1, "units")

    def atualizar_estrutura(self, event=None):
        classificacao = self.classificacao_selecionada.get()
        if not classificacao:
            return
        
        nivel_1, dados_planilha = self.processar_planilha_para_classificacao(classificacao)
        
        if not nivel_1 or not dados_planilha:
            messagebox.showerror("Erro", f"Não foi possível carregar dados para a classificação {classificacao}")
            return
        
        # Limpar frames antigos
        for widget in self.nivel1_frame.winfo_children():
            widget.destroy()
        
        for widget in self.familia_frame.winfo_children():
            widget.destroy()
        
        for widget in self.exemplo_frame.winfo_children():
            widget.destroy()
        
        for frame in self.niveis_frames.values():
            frame.pack_forget()
            for widget in frame.winfo_children():
                widget.destroy()
        
        self.codigo_var.set("")
        self.campos_editaveis = {}
        
        # Atualizar Nível 1
        self.nivel1_frame.pack(fill=tk.X, padx=10, pady=5)
        tk.Label(self.nivel1_frame, text="(01) Nome Inicial:", font=("Arial", 11, "bold")).pack(anchor="w", pady=5)
        tk.Label(self.nivel1_frame, text=nivel_1, font=("Arial", 10)).pack(anchor="w", padx=20)
        self.nivel_1 = nivel_1
        
        # Determinar famílias disponíveis
        nivel_2_key = "(02)"
        if nivel_2_key not in dados_planilha:
            messagebox.showerror("Erro", f"Não foram encontrados dados para o nível {nivel_2_key}")
            return
        
        familias = [codigo for codigo, _ in dados_planilha[nivel_2_key] if not (isinstance(codigo, tuple) and codigo[0] == 'EDITAVEL')]
        
        # Frame para seleção de família
        self.familia_frame.pack(fill=tk.X, padx=10, pady=5)
        
        tk.Label(self.familia_frame, text="(02) Família:", font=("Arial", 11, "bold")).pack(anchor="w", pady=5)
        
        self.familia_selecionada = tk.StringVar()
        familia_combo = ttk.Combobox(
            self.familia_frame,
            values=familias,
            textvariable=self.familia_selecionada,
            state="readonly",
            font=("Arial", 11),
            width=15
        )
        familia_combo.pack(anchor="w", padx=20, pady=5)
        familia_combo.bind("<<ComboboxSelected>>", self.atualizar_niveis)
        
        # Exemplo de código
        self.exemplo_frame.pack(fill=tk.X, padx=10, pady=5)
        tk.Label(self.exemplo_frame, text="Exemplo:", font=("Arial", 10)).pack(side=tk.LEFT)
        self.exemplo_label = tk.Label(
            self.exemplo_frame, 
            textvariable=self.codigo_exemplo,
            font=("Courier", 10, "bold"),
            wraplength=700
        )
        self.exemplo_label.pack(side=tk.LEFT, padx=10)
        self.codigo_exemplo.set("Selecione uma família")
        
        # Armazenar estrutura de dados
        self.dados_planilha = dados_planilha
        self.estrutura = {}
        
        # Adicionar níveis ordenados
        niveis_ordenados = sorted(dados_planilha.keys())
        for nivel in niveis_ordenados:
            if nivel not in ["(01)", "(02)"]:
                self.estrutura[nivel] = dados_planilha[nivel]
        
        # Inicializar seleções
        self.selecoes = {nivel: None for nivel in self.estrutura}
        self.selecoes["(01)"] = nivel_1
        self.selecoes["(02)"] = self.familia_selecionada

    def atualizar_niveis(self, event=None):
        familia = self.familia_selecionada.get()
        if not familia:
            return
        
        # Limpar frames de níveis
        for frame in self.niveis_frames.values():
            frame.pack_forget()
            for widget in frame.winfo_children():
                widget.destroy()
        
        # Criar frames para cada nível
        self.niveis_frames = {}
        niveis_ordenados = sorted(self.estrutura.keys())
        
        for nivel in niveis_ordenados:
            opcoes = self.estrutura[nivel]
            nivel_frame = tk.Frame(self.content_frame, bd=2, relief=tk.GROOVE, padx=10, pady=10)
            self.niveis_frames[nivel] = nivel_frame
            nivel_frame.pack(fill=tk.X, padx=10, pady=5)
            
            tk.Label(nivel_frame, text=nivel, font=("Arial", 11, "bold")).pack(anchor="w", pady=5)
            
            # Verifica se há campos editáveis neste nível
            tem_editaveis = any(isinstance(opcao, tuple) and len(opcao) == 3 and opcao[0] == 'EDITAVEL' for opcao in opcoes)
            
            if tem_editaveis:
                self.create_dynamic_editable_widgets(nivel_frame, nivel, opcoes)
            else:
                if ("", "Vazio") not in opcoes:
                    opcoes.insert(0, ("", "Vazio"))
                self.create_standard_widgets(nivel_frame, nivel, opcoes)
        
        # Empacotar o frame inferior com botões e código gerado
        self.bottom_frame.pack(fill=tk.X, pady=10)
        self.btn_frame.pack(fill=tk.X, padx=10)
        self.codigo_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.atualizar_exemplo()

    def create_dynamic_editable_widgets(self, parent, nivel, opcoes):
        var_nivel = tk.StringVar()
        self.selecoes[nivel] = var_nivel
        
        # Adiciona opção "Vazio" no início
        frame_vazio = tk.Frame(parent)
        frame_vazio.pack(anchor="w", pady=2)
        
        tk.Radiobutton(
            frame_vazio,
            text="",
            variable=var_nivel,
            value="",
            font=("Arial", 9),
            anchor="w"
        ).pack(side=tk.LEFT)
        
        tk.Label(
            frame_vazio,
            text="Vazio",
            font=("Arial", 9),
            anchor="w"
        ).pack(side=tk.LEFT)
        
        # Processa as opções editáveis
        for item in opcoes:
            if isinstance(item, tuple) and len(item) == 3 and item[0] == 'EDITAVEL':
                codigo = item[1]
                descricao = item[2]
                
                frame = tk.Frame(parent)
                frame.pack(anchor="w", pady=2)
                
                rb = tk.Radiobutton(
                    frame,
                    text="",
                    variable=var_nivel,
                    value=codigo,
                    font=("Arial", 9),
                    anchor="w"
                )
                rb.pack(side=tk.LEFT)
                
                if codigo.lower() == 'x/x':
                    capacidade = tk.Entry(frame, width=4, font=("Arial", 9))
                    capacidade.pack(side=tk.LEFT, padx=2)
                    
                    tk.Label(frame, text="/", font=("Arial", 9)).pack(side=tk.LEFT)
                    
                    circuitos = tk.Entry(frame, width=2, font=("Arial", 9))
                    circuitos.pack(side=tk.LEFT)
                    
                    self.campos_editaveis[f"{nivel}_capacidade"] = capacidade
                    self.campos_editaveis[f"{nivel}_circuitos"] = circuitos
                    
                elif codigo.lower() == 'xr':
                    filas = tk.Entry(frame, width=2, font=("Arial", 9))
                    filas.pack(side=tk.LEFT, padx=2)
                    
                    tk.Label(frame, text="R", font=("Arial", 9)).pack(side=tk.LEFT)
                    
                    self.campos_editaveis[f"{nivel}_filas"] = filas
                
                tk.Label(frame, text=descricao, font=("Arial", 9)).pack(side=tk.LEFT, padx=5)
        
        var_nivel.set("")

    def create_standard_widgets(self, parent, nivel, opcoes):
        var_nivel = tk.StringVar()
        self.selecoes[nivel] = var_nivel
        
        for codigo, descricao in opcoes:
            frame = tk.Frame(parent)
            frame.pack(anchor="w", pady=2)
            
            rb = tk.Radiobutton(
                frame,
                text="",
                variable=var_nivel,
                value=codigo,
                font=("Arial", 9),
                anchor="w"
            )
            rb.pack(side=tk.LEFT)
            
            desc_label = tk.Label(
                frame,
                text=f"{codigo} - {descricao}" if codigo else "Vazio",
                font=("Arial", 9),
                anchor="w",
                justify=tk.LEFT,
                wraplength=650
            )
            desc_label.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        var_nivel.set("")

    def atualizar_exemplo(self, event=None):
        if hasattr(self, 'nivel_1') and self.familia_selecionada.get():
            exemplo = f"{self.nivel_1}-{self.familia_selecionada.get()}"
            
            for nivel in sorted(self.estrutura.keys()):
                exemplo += f"-{nivel[1:3]}"
            
            self.codigo_exemplo.set(exemplo)
        else:
            self.codigo_exemplo.set("Selecione uma família")

    def limpar_selecoes(self):
        self.classificacao_selecionada.set("")
        self.familia_selecionada.set("")
        
        for nivel in self.selecoes:
            if isinstance(self.selecoes[nivel], tk.StringVar):
                self.selecoes[nivel].set("")
        
        # Limpa apenas os campos editáveis
        for campo in self.campos_editaveis.values():
            if isinstance(campo, tk.Entry):
                campo.delete(0, tk.END)
        
        self.codigo_var.set("")
        self.codigo_exemplo.set("Selecione uma classificação")

    def gerar_codigo(self):
        if not hasattr(self, 'nivel_1') or not self.nivel_1:
            messagebox.showwarning("Aviso", "Selecione uma classificação de equipamento")
            return
        
        if not self.familia_selecionada.get():
            messagebox.showwarning("Aviso", "Selecione uma família")
            return
        
        partes_codigo = [self.nivel_1, self.familia_selecionada.get()]
        
        for nivel, var in self.selecoes.items():
            if nivel in ["(01)", "(02)"]:
                continue
                
            if isinstance(var, tk.StringVar):
                selecao = var.get()
                
                if not selecao:  # Ignora se for vazio
                    continue
                    
                # Verifica se é um campo editável
                if any(isinstance(opcao, tuple) and len(opcao) == 3 and opcao[0] == 'EDITAVEL' 
                      for opcao in self.estrutura.get(nivel, [])):
                    
                    if selecao.lower() == 'x/x':
                        cap = self.campos_editaveis.get(f"{nivel}_capacidade", None)
                        cir = self.campos_editaveis.get(f"{nivel}_circuitos", None)
                        if cap and cir and cap.get().strip() and cir.get().strip():
                            selecao = f"{cap.get().strip()}/{cir.get().strip()}"
                        else:
                            messagebox.showwarning("Aviso", f"Preencha os valores para o nível {nivel}")
                            return
                            
                    elif selecao.lower() == 'xr':
                        fil = self.campos_editaveis.get(f"{nivel}_filas", None)
                        if fil and fil.get().strip():
                            selecao = f"{fil.get().strip()}R"
                        else:
                            messagebox.showwarning("Aviso", f"Preencha o valor para o nível {nivel}")
                            return
                
                partes_codigo.append(selecao)
        
        if len(partes_codigo) == 2:
            messagebox.showwarning("Aviso", "Selecione pelo menos uma opção nos níveis")
            return
        
        self.codigo_var.set("-".join(partes_codigo))

if __name__ == "__main__":
    root = tk.Tk()
    app = FancoleteConfigurador(root)
    root.mainloop()